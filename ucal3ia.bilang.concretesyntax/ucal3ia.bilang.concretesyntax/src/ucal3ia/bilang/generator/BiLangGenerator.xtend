/*
 * generated by Xtext 2.25.0
 */
package ucal3ia.bilang.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import ucal3ia.bilang.abstractsyntax.Task
import java.util.HashMap
import java.util.ArrayList
import ucal3ia.bilang.abstractsyntax.FileExtractor
import java.io.BufferedReader
import java.io.FileReader
import java.util.Arrays
import ucal3ia.bilang.abstractsyntax.DataFiltering
import ucal3ia.bilang.abstractsyntax.DashBoard
import ucal3ia.bilang.abstractsyntax.BarPlot
import ucal3ia.bilang.abstractsyntax.QuantitativeFiltering
import ucal3ia.bilang.abstractsyntax.QualitativeFiltering
import ucal3ia.bilang.abstractsyntax.MathOperation
import ucal3ia.bilang.abstractsyntax.ColReference
import ucal3ia.bilang.abstractsyntax.StatisticalOperation
import ucal3ia.bilang.abstractsyntax.LinePlot
import ucal3ia.bilang.abstractsyntax.RadarPlot
import ucal3ia.bilang.abstractsyntax.PiePlot
import ucal3ia.bilang.abstractsyntax.ScatterPlot
import ucal3ia.bilang.abstractsyntax.PolarPlot
import ucal3ia.bilang.abstractsyntax.DonutPlot
import java.util.Collections

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class BiLangGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		System.out.println("------------------------------")
		var Task task= resource.allContents.head as Task
		var dataArray= new HashMap<String, HashMap<String, ArrayList<String>>>;
		var dashBoardContent= new HashMap<FileExtractor, HashMap<String, HashMap<String, Object>>>;
		var fileExtractName= "";
		var fileContent= '''
		<!DOCTYPE html>
		<html>
		<head>
		  <title>Exemple de graphique avec Chart.js</title>
		  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
		  <script src="./fs"></script>
		  <script src="./csv-parser"></script>
		  <style>
		      .chart-container {
		        display: inline-block;
		        width: 600px;
		        height: 600px;
		        margin: 10px;
		      }
		  </style>
		
		</head>
		<body>
		
		'''
		for (extractor:task.fileextractor) {
			var extractorData= translateFileExtractor(extractor)
			dataArray.put(extractor.name, extractorData);
		}
		for (filter:task.datafiltering) {
			var inputData= dataArray.get(filter.fileextractor.name)
			//var filteredData= 
			dataArray.put(filter.fileextractor.name, translateDataFiltering(filter, inputData))
		}
		var fileExtractors= new ArrayList<FileExtractor>()
		for (fileExtractor: task.dashboard.fileextractor) {
			fileExtractors.add(fileExtractor)
		}
		dashBoardContent= translateDashBoard(task.dashboard, fileExtractors, dataArray)
			/*if (dashboard.datafiltering != null) {
				fileContent += translateDashBoardManager(dashboard, dataArray.get(dashboard.datafiltering));
			} else {
				fileContent += translateDashBoardManager(dashboard, dataArray.get(dashboard.fileextractor))
			}*/
			
		fileContent+= displayDashboard(dashBoardContent, dataArray)
		
		fileContent += '''
		</script>
		</body>
		</html>
		'''
		fsa.generateFile(task.name+".html", fileContent)
	}
	
	//FONCTION PERMETTANT DE STOCKER ET ORGANISER LES DONNÈES | BASE DE DONNÈE UTILISÈE DANS TOUTES LES AUTRES FONCTIONS
	def translateFileExtractor(FileExtractor fe) {
		var i=0
		var fileName= "";
		for (str:fe.path.split("\\.")) {
			if (str.contains("/")) {
				for(tk:str.split("/")){
					fileName= tk;
				}
			}
		}
		var csvData= new ArrayList<ArrayList<String>>();
		var allData= new HashMap<String, ArrayList<String>>();
		var labels= new ArrayList<String>;
		var row= "";
		try {
			var iterator= new BufferedReader(new FileReader(fe.path));
			var z=0;
			while((row= iterator.readLine()) != null) {
				if (z ==0) {
					labels= new ArrayList<String>(Arrays.asList(row.split(";")));
				} else if (z == 1) {
					
				} else {
					csvData.add(new ArrayList<String>(Arrays.asList(row.split(";"))));
				}
				z++;
			}
		} catch(Exception e) {
   			e.printStackTrace();
		}
		var k= 0;
		for (String lab: labels) {
			var colData= new ArrayList<String>();
			for (var j=0; j<csvData.size(); j++) {
				if (k >= (csvData.get(j)).length()) {
					colData.add("");
				} else
					colData.add(csvData.get(j).get(k));
			}
			allData.put(lab, colData);
           	k++;
		}
		for (preprocess: fe.nullreplacement) {
			if (allData.containsKey(preprocess.colName)) {
				var colData= allData.get(preprocess.colName)
				if (preprocess.label != null) {
					for (var j= 0; i < colData.size(); i++) {
						if ((colData.get(j)).equals("")) {
							colData.set(j, preprocess.label)
						}
					}
				} else if (preprocess.statisticaloperation != null) {
					var value= (computeStatisticOperation((preprocess.statisticaloperation.colreference).target, (preprocess.statisticaloperation).operator.literal, allData)).get(0)
					for (var j= 0; j < colData.size(); j++) {
						if ((colData.get(j)).equals("")) {
							colData.set(j,value)
						}
					}
				}
				allData.replace(preprocess.colName, colData) 
			} else if ((preprocess.colName). equals("ALL")) {
				for (String label: allData.keySet()) {
					var colData= allData.get(label)
					if (preprocess.label != null) {
						for (var j= 0; j < colData.size(); j++) {
							var value= colData.get(j)
							if ((colData.get(j)).equals("")) {
								colData.set(j, preprocess.label)
							}
						}
					} else if (preprocess.statisticaloperation != null) {
						var value= (computeStatisticOperation((preprocess.statisticaloperation.colreference).target, (preprocess.statisticaloperation).operator.literal, allData)).get(0)
						for (var j= 0; i < colData.size(); i++) {
							if ((colData.get(j)).equals("")) {
								colData.set(j,value)
							}
						}
					}
					allData.replace(label, colData)	
				}
			}
		}
			
		return allData
	}
	
	//FONCTION PERMETTANT D'EFFECTUER LES TRAITEMENT / FILTRAGE DES DONNÈES DU CSV
	def translateDataFiltering(DataFiltering df, HashMap<String, ArrayList<String>> fileData) {
		var filteredData= new HashMap<String, ArrayList<String>>;
		var targets= new ArrayList<String>()	
		var operationContent= new ArrayList<String>()
		var formulaMap= new HashMap<Object, Object>
		var colLenght= 0
		/* Copie du contenu du fichier CSV / EXCEL */
		for (lab:fileData.keySet()) {
			filteredData.put(lab, (fileData.get(lab)));
			colLenght= (fileData.get(lab)).size()
		}
		//PHASE DE PREPROCESSING 
		for (preprocess:df.processingstep) {
			var newFieldData= new ArrayList<String>();
			if (preprocess instanceof MathOperation) {
				newFieldData= MathOperationAlgorithm(preprocess as MathOperation, filteredData)
				filteredData.put("TEST", newFieldData);
				System.out.println(newFieldData)
			} else if (preprocess instanceof StatisticalOperation) {
				
				//filteredData.put(operator.literal, statVal);
			}
		
		}
		//PHASE DE FILTRAGE
		var stopLoop= false;
		for (filter:df.filteringstep){
			// RECUPERATION DES CARACTERISTIQUES DU FILTRE | Axe cible et Valeur(s) ‡ conserver
			var targetCol= fileData.get(filter.axis)
			var targetCondition= false
			var main_operator= ""
			if (filter instanceof QuantitativeFiltering) {
				stopLoop= false;
				main_operator= filter.operator.literal
				var targetValue= filter.values
				for(var i= 0; i<targetCol.size(); i++) {
					if ((main_operator).equals("<")) {
						targetCondition= (Float.parseFloat(targetCol.get(i)) < targetValue);
					}	
					else if ((main_operator).equals(">")) {
						targetCondition= (Float.parseFloat(targetCol.get(i)) > targetValue);
					}
					else
						targetCondition= (Float.parseFloat(targetCol.get(i)) == targetValue);
						
					while ((stopLoop == false) &&  (targetCondition == false)) {
						if ((main_operator).equals("<")) {
							targetCondition= (Float.parseFloat(targetCol.get(i)) < targetValue);
						}
						else if ((main_operator).equals(">")) {
							targetCondition= (Float.parseFloat(targetCol.get(i)) > targetValue);
						}
						else
							targetCondition= (Float.parseFloat(targetCol.get(i)) == targetValue);
						if (targetCondition == false) {
							for (String lab:filteredData.keySet()) {
								if (i == targetCol.size()) {
									stopLoop= true;
								}
								if (filteredData.get(lab).size() > i)
									filteredData.get(lab).remove(i)	
							}
						}
					}	
				}
			} if (filter instanceof QualitativeFiltering) {
				stopLoop= false
				if ((filter.axis).equals("ALL")) {
					main_operator= filter.operator.literal
					if (main_operator.equals("!=")) {
						targetCondition= true
					}
					//NETTOYAGE DES DONNÈES SELON LES CA
					var haveDelete= false
					var updateLenght= colLenght-1
					for(var i= 0; i<colLenght; i++) {			
						for (lab:filteredData.keySet()){
							haveDelete= false
							while ((stopLoop == false) && (((filteredData.get(lab)).get(i)).equals(filter.labels) == targetCondition)){
								if (i == updateLenght) 
									stopLoop= true;
								for (l: filteredData.keySet()) {	
									if (filteredData.get(l).size() > i)
										filteredData.get(l).remove(i)		
								}
								updateLenght--
							}
						}
						
					}
				} else {
					if (filter.labels.contains(", "))
						targets= new ArrayList<String>(Arrays.asList(filter.labels.split(", ")))
					else if (filter.labels.contains(","))
						targets= new ArrayList<String>(Arrays.asList(filter.labels.split(",")))
					else 
						targets.add(filter.labels)
					main_operator= filter.operator.literal
					if (main_operator.equals("!=")) {
						targetCondition= true
					}
					//NETTOYAGE DES DONNÈES SELON LES CA
					for(var i= 0; i<targetCol.size(); i++) {
						while ((stopLoop == false) && (targets.contains(targetCol.get(i)) == targetCondition)){
							for (lab:filteredData.keySet()){
								if (i == targetCol.size()) {
									stopLoop= true;
								}
								if (filteredData.get(lab).size() > i)
									filteredData.get(lab).remove(i)	
							}
						}
					}	
				}
			}
				
		}
		return filteredData	
	}
	
	//FONCTION DE STOCKAGE DES CARACTERISTIQUES DES GRAPHIQUES
	def translateDashBoard(DashBoard db, ArrayList<FileExtractor> extractors, HashMap<String, HashMap<String, ArrayList<String>>> filesData) {
		//var dashBoardContent= new HashMap<String, HashMap<String, Object>>
		var dashBoardContent= new HashMap<FileExtractor, HashMap<String, HashMap<String, Object>>>
		var plotType= ""
		var p= 0
		for (plot:db.plot) {
			var plotContent= new HashMap<String, Object>
			var key= plot.name
			var xAxis= new ArrayList<String>()
			var colors= new ArrayList<String>()
			//RÈcupÈration de la / des couleurs du graphique
			if (plot.colors != null) {
				if ((plot.colors).contains(", ")){
					for (color:(plot.colors).split(", ")) {
						colors.add(color)
					}
					plotContent.put("colors", colors)
				} else if ((plot.colors).contains(",")) {
					for (color:(plot.colors).split(",")) {
						colors.add(color)
					}
					plotContent.put("colors", colors)
				}else
					colors.add(plot.colors)
					plotContent.put("colors", colors)		
			}
			//RÈcupÈration du type de graphique
			if (plot instanceof BarPlot) 
				plotContent.put("type", "bar")
			else if (plot instanceof ScatterPlot)
				plotContent.put("type", "scatter")
			else if (plot instanceof LinePlot) 
				plotContent.put("type", "line")
			else if (plot instanceof PiePlot)
				plotContent.put("type", "pie")
			else if (plot instanceof PolarPlot)
				plotContent.put("type", "polarArea")
			else if (plot instanceof DonutPlot)
				plotContent.put("type", "doughnut")
			else if (plot instanceof RadarPlot)
				plotContent.put("type", "radar")
			//RÈcupÈration des axes en abscisses
			if ((plot.XAxis).contains(", ")){
				for (lab:(plot.XAxis).split(", ")) {
					xAxis.add(lab)
				}
				plotContent.put("xAxis", xAxis)
			}
			else if ((plot.XAxis).contains(",")) {
				for (lab:(plot.XAxis).split(",")) {
					xAxis.add(lab)
				}
				plotContent.put("xAxis", xAxis)
			} else {
				xAxis.add(plot.XAxis)
				plotContent.put("xAxis", plot.XAxis)
			}		
			//RÈcupÈration des axes en ordonnÈes
			var yAxis= new ArrayList<String>()
			if ((plot.YAxis).contains(", ")){
				for (lab:(plot.YAxis).split(", ")) {
					yAxis.add(lab)
				}
				plotContent.put("yAxis", yAxis)
			}
			else if ((plot.YAxis).contains(",")) {
				for (lab:(plot.YAxis).split(",")) {
					yAxis.add(lab)
					
				}
				plotContent.put("yAxis", yAxis)
			} else {
				yAxis.add(plot.YAxis)
				plotContent.put("yAxis", plot.YAxis)
			}
			//RÈcupÈration de la position du graphique, epaisseur des lignes / barres / etc...
			if (plot.location != -1) {
				plotContent.put("location", plot.location)	
			} else
				plotContent.put("location", p)	
			if (plot.thickness != 0.0) {
				plotContent.put("thickness", Float.toString(plot.thickness))	
			}
			for (extractor: extractors) {
				if (((filesData.get(extractor.name)).keySet()).containsAll(yAxis) &&  ((filesData.get(extractor.name)).keySet()).containsAll(xAxis)){
					var plotMap= new HashMap<String, HashMap<String, Object>>
					if (!dashBoardContent.containsKey(extractor)) {	
						plotMap.put(key, plotContent)
						
					} else {
						plotMap= dashBoardContent.get(extractor)
						plotMap.put(key, plotContent)
					}
					// Stockage dans la map globale du dashboard
					dashBoardContent.put(extractor, plotMap)
					p++
					System.out.println(dashBoardContent)
				}		
			}
		}
		
		return dashBoardContent
	}
	
	//FONCTION PERMETTANT D'UTILISER LES DONNÈES CARACTÈRISTIQUES DES GRAPHIQUES ET DONNÈES DU CSV POUR AFFICHER LES GRAPHIQUES SUR LA PAGE WEB
	def displayDashboard(HashMap<FileExtractor, HashMap<String, HashMap<String, Object>>> dashboardContent, HashMap<String, HashMap<String, ArrayList<String>>> filesData) {
		var displayDashboard= ""	
		var content= ""
		var targetkey= ""
		var nbPlot= 0
		for(fileExtractor: dashboardContent.keySet()) {
			nbPlot+= ((dashboardContent.get(fileExtractor)).keySet()).length()
		}
		 
		for (var i= 0; i < nbPlot; i++) {
			for(fileExtractor: dashboardContent.keySet()) {
				var filePlot= dashboardContent.get(fileExtractor)
				for (key: filePlot.keySet()) {
					if ((filePlot.get(key)).containsKey("location") && (filePlot.get(key)).get("location") == i) {
						content+= '''<div class="chart-container">
				<canvas id="''' + key + '''"></canvas>
				</div>'''
						content+= "\n"
					}
				}
				
			}
		}
		/*for(fileExtractor: dashboardContent.keySet()) {
			var filePlot= dashboardContent.get(fileExtractor)
			for (var i= plotNum; i < (filePlot.keySet()).length()+plotNum; i++) {
				for (key: filePlot.keySet()) {
					if ((filePlot.get(key)).containsKey("location") && (filePlot.get(key)).get("location") == i) {
						targetkey= key
						plotNum= i+1
					}
				}
				content+= '''<div class="chart-container">
				<canvas id="''' + targetkey + '''"></canvas>
				</div>'''
				content+= "\n"
			}	
		}*/
		content+='''
				
				<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
				<script>
				  	const CHART_COLORS = {
				  	  redt: 'rgba(255, 99, 132, 0.6)',
				  	  red: 'rgb(255, 99, 132)',
				  	  orange: 'rgb(255, 159, 64)',
				  	  yellow: 'rgb(255, 205, 86)',
				  	  green: 'rgb(75, 192, 192)',
				  	  bluet: 'rgba(54, 162, 235,0.6)',
				  	  blue: 'rgb(54, 162, 235)',
				  	  purple: 'rgb(153, 102, 255)',
				  	  grey: 'rgb(201, 203, 207)'
				  	};
				  	
				  	const NAMED_COLORS = [
				  	  CHART_COLORS.red,
				  	  CHART_COLORS.orange,
				  	  CHART_COLORS.yellow,
				  	  CHART_COLORS.green,
				  	  CHART_COLORS.blue,
				  	  CHART_COLORS.purple,
				  	  CHART_COLORS.grey,
				  	];''';
		var j=0
		for(fileExtractor: dashboardContent.keySet()) {
			var filePlot= dashboardContent.get(fileExtractor)
			var fileData= filesData.get(fileExtractor.name)
			for (keyPlot:filePlot.keySet()) {
				var plotType= filePlot.get(keyPlot).get("type")
				var xLabs= new ArrayList<String>()
				var yLabs= new ArrayList<String>()
				if (filePlot.get(keyPlot).get("xAxis") instanceof ArrayList) {
					xLabs= filePlot.get(keyPlot).get("xAxis") as ArrayList
				} else {
					xLabs.add(filePlot.get(keyPlot).get("xAxis") as String)
				}
				
				if (filePlot.get(keyPlot).get("yAxis") instanceof ArrayList) {
					yLabs= filePlot.get(keyPlot).get("yAxis") as ArrayList
				} else {
					yLabs.add(filePlot.get(keyPlot).get("yAxis") as String)
				}
				
				var yCols= new ArrayList<ArrayList<String>>();
				var xCols= new ArrayList<ArrayList<String>>();	
				for (var a= 0; a < yLabs.size(); a++) 
					yCols.add(fileData.get(yLabs.get(a)));
		
				for (var a= 0; a < xLabs.size(); a++) 
					xCols.add(fileData.get(xLabs.get(a)));
				content += "\n"+'''	const file''' + j+1 + '''= ['''
				var yLength= yCols.get(0).length()
				for (var i= 0; i < yLength; i++) {
					content+='''	{'''
					for (var cx= 0; cx < xCols.length(); cx++)
						content+= xLabs.get(cx) + ''': "''' + xCols.get(cx).get(i) + '''", '''
						//content+= dbm.plot.get(j).XAxis + ''': "''' + xCol.get(i) + '''", ''' + dbm.plot.get(j).YAxis + ''': "''' + yCol.get(i) + '''"},'''
					for (var cy= 0; cy < yCols.length(); cy++)
						content+= yLabs.get(cy) + ''': "''' + yCols.get(cy).get(i) + '''", '''
					//content-= ''', '''
					content += "},\n"
				}
				content += '''	];'''
				content += "\n"
				content += '''	''' + keyPlot + '''= new Chart(
			document.getElementById("''' + keyPlot + '''"),
			{
				type: "''' + plotType + '''",
				data: {''' 
				for (xax: xLabs) {	
					
					content+= '''
					labels: file''' + j+1 + '''.map(row => row.''' + xax + '''),
					datasets: [
						''' 
					
					var value= new ArrayList<String>()
					if (filePlot.get(keyPlot).containsKey("colors")) {
						value= filePlot.get(keyPlot).get("colors") as ArrayList
					}
					var convertColors= new ArrayList<String>()
					for (col: value) {
						if (value.contains("#")) {
							var hexR= (col as String).substring(1, 3)
							var hexG= (col as String).substring(3, 5)
							var hexB= (col as String).substring(5)
							convertColors.add("rgba(" + hexR + hexG + hexB + ", 0.6)" )
						} else
							convertColors.add((col as String))
					}
					for (var a= 0; a < yLabs.size(); a++) { 
						if (convertColors.size()> 1) {	
							content+= '''					{
					    		label: "''' + yLabs.get(a) + '''",
					        	data: file''' + j+1 + '''.map(row => row.''' + yLabs.get(a) + '''),
					        	borderColor: "''' + convertColors.get(a) + '''",''' + "\n"
					        	if (filePlot.get(keyPlot).containsKey("thickness"))
					        		content+='''				borderWidth: ''' + filePlot.get(keyPlot).get("thickness") + ",\n"
					        	content+=  '''			},'''  
					   	} else if (convertColors.size() == 1) {
					   		content+= '''					{
					    		label: "''' + yLabs.get(a) + '''",
					        	data: file''' + j+1 + '''.map(row => row.''' + yLabs.get(a) + '''),
					        	borderColor: "''' + convertColors.get(0) + '''"'''
					        	if (filePlot.get(keyPlot).containsKey("thickness")) 
					        		content+= '''
					        	borderWidth: ''' + filePlot.get(keyPlot).get("thickness") 
					        	content+= ''',
					    	},
					    	'''  
					   	} else {
					   		content+= '''					{
					    		label: "''' + yLabs.get(a) + '''",
					        	data: file''' + j+1 + '''.map(row => row.''' + yLabs.get(a)+ ''')'''
					        	if (filePlot.get(keyPlot).containsKey("thickness")) 
					        		content+= '''
					        	borderWidth: ''' + filePlot.get(keyPlot).get("thickness") 
					        	content+= ''',
					    	},
					    	'''
					   	}
					}
					
				}
				    	content+= '''
					]
				}
			}
		);
						
				'''
			j++		
			}
		}
		return content
	}
	
	def ArrayList<String> computeStatisticOperation(String targetCol, String operator, HashMap<String, ArrayList<String>> fileData){
		var colRef= new ArrayList<Float>()
		for (value: fileData.get(targetCol)) {
			colRef.add(Float.parseFloat(value))
		}
		Collections.sort(colRef)
		var sum= 0 as float
		var statVal= new ArrayList<String>
		if (operator.equals("MEAN")) {
			for (var i= 0; i < colRef.size(); i++) {
				sum+= colRef.get(i)
			}	
			statVal.add((sum / colRef.size()).toString())
			
									
		} else if (operator.equals("MEDIAN")) {
			if (colRef.size() % 2 != 0) {
				statVal.add((colRef.get((colRef.size() / 2) +1)).toString()) 
			}
			else {
				var fval= colRef.get(colRef.size() / 2)
				var sval= colRef.get((colRef.size() / 2) +1)
				statVal.add(((fval + sval) / 2).toString)
			}
						
		} else {
	        var standardDeviation = 0 as float;
	
	        for(num : colRef) {
	            sum += num;
	        }
	
	        var mean = sum/colRef.size();
	
	        for(num: colRef) {
	        	
	            standardDeviation += Math.pow(num - mean, 2) as float;
	        }
	
	        statVal.add(Math.sqrt(standardDeviation/colRef.size()).toString());
	        
	    }
	    return statVal 
    }
	
	def ArrayList<String> computeColsOperation(Object lSide, String operator, Object rSide, HashMap<String, ArrayList<String>> csvData) {
        var newFieldData= new ArrayList<String>();
        var lData= new ArrayList<String>();
        var rData= new ArrayList<String>();
        var isStatistic= false
        if (lSide instanceof StatisticalOperation && rSide instanceof StatisticalOperation) {
        	
        } else if ((lSide instanceof String) && (rSide instanceof String)) {
            lData= csvData.get(lSide);
            rData= csvData.get(rSide);
        }
        else if (lSide instanceof String) {
        	lData= csvData.get(lSide);
        	if (rSide instanceof ArrayList) {
            	rData= rSide as ArrayList<String>;	
            } else {
            	rData= computeStatisticOperation((rSide as StatisticalOperation).colreference.target, (rSide as StatisticalOperation).operator.literal, csvData)
            	isStatistic= true
            }
            
        } else if (rSide instanceof String){
        	rData= csvData.get(rSide);
        	if (lSide instanceof ArrayList) {
            	lData= lSide as ArrayList<String>;	
            } else {
            	lData= computeStatisticOperation((lSide as StatisticalOperation).colreference.target, (lSide as StatisticalOperation).operator.literal, csvData)
            	isStatistic= true
            }
        } else {
            lData= lSide as ArrayList<String>;
            rData= rSide as ArrayList<String>;
        }
        
        if (isStatistic) {
        	if (lSide instanceof StatisticalOperation) {
        		var lSideValue= lData.get(0);
        		for (var i= 0; i < rData.size(); i++) {
        			var rSideValue= rData.get(i);
		            var result= 0 as float;
		            if (operator.equals("+")) {
		                result= Float.parseFloat(lSideValue) + Float.parseFloat(rSideValue);
		            } else if (operator.equals("-")) {
		                result= Float.parseFloat(lSideValue) - Float.parseFloat(rSideValue);
		            } else if (operator.equals("*")) {
		                result= Float.parseFloat(lSideValue) * Float.parseFloat(rSideValue);
		            } else if (operator.equals("/")) {
		                result= Float.parseFloat(lSideValue) / Float.parseFloat(rSideValue);
		            }
		            newFieldData.add(Float.toString(result));
        		}
        	} else {
        		var rSideValue= rData.get(0);
        		for (var i= 0; i < lData.size(); i++) {
        			var lSideValue= lData.get(i);
		            var result= 0 as float;
		            if (operator.equals("+")) {
		                result= Float.parseFloat(lSideValue) + Float.parseFloat(rSideValue);
		            } else if (operator.equals("-")) {
		                result= Float.parseFloat(lSideValue) - Float.parseFloat(rSideValue);
		            } else if (operator.equals("*")) {
		                result= Float.parseFloat(lSideValue) * Float.parseFloat(rSideValue);
		            } else if (operator.equals("/")) {
		                result= Float.parseFloat(lSideValue) / Float.parseFloat(rSideValue);
		            }
		            newFieldData.add(Float.toString(result));
        		}
        	}
        	
        } else {
	        for (var i= 0; i < lData.size(); i++) {
	            var lSideValue= lData.get(i);
	            var rSideValue= rData.get(i);
	            var result= 0 as float;
	            if (operator.equals("+")) {
	                result= Float.parseFloat(lSideValue) + Float.parseFloat(rSideValue);
	            } else if (operator.equals("-")) {
	                result= Float.parseFloat(lSideValue) - Float.parseFloat(rSideValue);
	            } else if (operator.equals("*")) {
	                result= Float.parseFloat(lSideValue) * Float.parseFloat(rSideValue);
	            } else if (operator.equals("/")) {
	                result= Float.parseFloat(lSideValue) / Float.parseFloat(rSideValue);
	            }
	            newFieldData.add(Float.toString(result));
	        }   
	    }
        return newFieldData;
    }


    def ArrayList<String> MathOperationAlgorithm(MathOperation mainOp, HashMap<String, ArrayList<String>> csvData) {
        var formulaMap= new HashMap<MathOperation, Object>();
        var newFieldData= new ArrayList<String>();
        var mainColRef= 0;
        var lSide= mainOp.lside;
        var rSide= mainOp.rside;
        var operator= mainOp.operator;
        var currentOp= mainOp;
        var operation= new HashMap<String, Object>();
                operation.put("l", lSide);
                operation.put("o", operator.literal);
                operation.put("r", rSide);
                operation.put("isMapped", false);
        formulaMap.put(mainOp, operation);
        var status1= false;
        var status2= false
        if (lSide instanceof MathOperation || rSide instanceof MathOperation) {
            while (status1 == false) {
                var prevOp= currentOp;
                var lState= false as Boolean;
                var rState= false as Boolean;
                if (formulaMap.containsKey(currentOp.lside)) {
                    lState= (formulaMap.get(currentOp.lside) as HashMap<String, Object>).get("isMapped") as Boolean;
                } if (formulaMap.containsKey(currentOp.rside)) {
                  	rState= (formulaMap.get(currentOp.rside) as HashMap<String, Object>).get("isMapped") as Boolean;
                }
                if (currentOp.lside instanceof MathOperation && lState == false){
                    currentOp= currentOp.lside as MathOperation;    
                }
                else if (currentOp.rside instanceof MathOperation && rState == false) {
                    currentOp= currentOp.rside as MathOperation;    
                }
                else if ((lState && rState) || ((currentOp.lside instanceof ColReference) && rState) || (lState && !(currentOp.rside instanceof ColReference))) {
                    if (currentOp.lside instanceof MathOperation && currentOp.rside instanceof MathOperation) {
                        var lSideOperation= formulaMap.get(currentOp.lside);
                        var rSideOperation= formulaMap.get(currentOp.rside);
                        var preprocess_data= computeColsOperation((lSideOperation as HashMap<String, Object>).get("preprocess_data"), currentOp.operator.literal, (rSideOperation as HashMap<String, Object>).get("preprocess_data"), csvData);
                        var mainData= formulaMap.get(currentOp) as HashMap<String, Object>;
                        mainData.put("preprocess_data", preprocess_data);
                        formulaMap.put(currentOp, mainData);
                    } else if (currentOp.lside instanceof MathOperation) {
                        var lSideOperation= formulaMap.get(currentOp.lside);
                        var rSideOperation= (currentOp.rside as ColReference).target;
                        var preprocess_data= computeColsOperation((lSideOperation as HashMap<String, Object>).get("preprocess_data"), currentOp.operator.literal, rSideOperation, csvData);
                        var mainData= formulaMap.get(currentOp) as HashMap<String, Object>;
                        mainData.put("preprocess_data", preprocess_data);
                        formulaMap.put(currentOp, mainData);
                    } else {
                        var lSideOperation= (currentOp.lside as ColReference).target;
                        var rSideOperation= formulaMap.get(currentOp.rside);
                        var preprocess_data= computeColsOperation(lSideOperation, currentOp.operator.literal, (rSideOperation as HashMap<String, Object>).get("preprocess_data"), csvData);
                        var mainData= formulaMap.get(currentOp) as HashMap<String, Object>;
                        mainData.put("preprocess_data", preprocess_data);
                        formulaMap.put(currentOp, mainData);
                    }
                    status1= true;
                }
                var currentLSide= currentOp.lside;
                var currentRSide= currentOp.rside;
                var currentOperator= currentOp.operator;
                   
                operation= new HashMap<String, Object>();
                operation.put("l", currentLSide);
                operation.put("o", currentOperator.literal);
                operation.put("r", currentRSide);
                operation.put("parent", prevOp);
                if ((currentLSide instanceof ColReference || currentLSide instanceof StatisticalOperation) && (currentRSide instanceof ColReference || currentRSide instanceof StatisticalOperation)) {
                    operation.put("isMapped", true);
                    var l= new Object()
                    var r= new Object()
                    if  (currentLSide instanceof ColReference && currentRSide instanceof ColReference) {
                    	l= (currentLSide as ColReference).target
                    	r= (currentRSide as ColReference).target	
                    } else if (currentLSide instanceof StatisticalOperation && currentRSide instanceof StatisticalOperation) {
                    	l= currentLSide
                    	r= currentRSide
                    }
                    else if (currentRSide instanceof StatisticalOperation) {
                    	l= (currentLSide as ColReference).target
                    	r= currentRSide
                    } else {
                    	l= currentLSide
                    	r= (currentRSide as ColReference).target
                    }
                    var preprocess_data= computeColsOperation(l, currentOperator.literal, r, csvData);
                    operation.put("preprocess_data", preprocess_data);
                    formulaMap.put(currentOp, operation);
                    var mainlSide= (formulaMap.get(mainOp.lside))
                    status2= false
                    while (status2 == false) {
                        var parentOperation= formulaMap.get(currentOp) as HashMap<String, Object>;
                        var parentObject= parentOperation.get("parent");
                        parentOperation= (formulaMap.get(parentOperation.get("parent")) as HashMap<String, Object>);
                        if(currentOp == mainOp) {
                            status2= true
                        } else if ((parentOperation.get("isMapped") as Boolean) == true) {
                            currentOp= parentOperation.get("parent") as MathOperation;
                            if (currentOp.lside instanceof MathOperation) {
                                lState= ((formulaMap.get(currentOp.lside) as HashMap<String, Object>).get("isMapped") as Boolean);
                                if (lState == false) {
                                    currentOp= currentOp.lside as MathOperation;
                                }
                            }
                            if (currentOp.rside instanceof MathOperation){
                                rState= (formulaMap.get(currentOp.rside as MathOperation) as HashMap<String, Object>).get("isMapped") as Boolean;
                                if (rState == false) {
                                    currentOp= currentOp.rside as MathOperation;
                                }
                            } 
                        } else {
                            currentOp= parentObject as MathOperation;
                            status2= true;
                        }
                    }

                } else {
                    if (formulaMap.containsKey(currentOp)) {
                        operation= formulaMap.get(currentOp) as HashMap<String, Object>;
                        var lSideOperation= new Object();
                        var rSideOperation= new Object();
                        var nbOperation= 0;
                        if (operation.get("l") instanceof MathOperation) {
                            lSideOperation= formulaMap.get(operation.get("l"));
                            nbOperation++;
                        }
                        else if (operation.get("l") instanceof ColReference) {
                            lSideOperation= operation.get("l") as ColReference;
                        }
                        if (operation.get("r") instanceof MathOperation) {
                            rSideOperation= formulaMap.get(operation.get("r")) as HashMap<String, Object>;
                            nbOperation++;
                        }
                        else if (operation.get("r") instanceof ColReference) {
                            rSideOperation= operation.get("r");
                        }
                        var operationOperator= operation.get("o") as String;
                        if (nbOperation == 2){ 
                            if ((lSideOperation as HashMap<String, Object>).containsKey("preprocess_data") && (rSideOperation as HashMap<String, Object>).containsKey("preprocess_data")) {
                                var preprocess_data= computeColsOperation(((lSideOperation as HashMap<String, Object>).get("preprocess_data") as ArrayList<String>), operationOperator, ((rSideOperation as HashMap<String, Object>).get("preprocess_data") as ArrayList<String>), csvData);
                                operation.put("preprocess_data", preprocess_data);
                                operation.put("isMapped", true);
                                currentOp= operation.get("parent") as MathOperation;
                            }
                        } 
                        else if (nbOperation == 1) {
                            if (operation.get("l") instanceof ColReference) {
                                var preprocess_data= computeColsOperation((lSideOperation as ColReference).target, operationOperator, ((rSideOperation as HashMap<String, Object>).get("preprocess_data") as ArrayList<String>), csvData);
                                operation.put("preprocess_data", preprocess_data);
                                operation.put("isMapped", true);
                                currentOp= operation.get("parent") as MathOperation;
                            } else {
                                var preprocess_data= computeColsOperation(((lSideOperation as HashMap<String, Object>).get("preprocess_data") as ArrayList<String>), operationOperator, (rSideOperation as ColReference).target, csvData);
                                operation.put("preprocess_data", preprocess_data);
                                operation.put("isMapped", true);
                                currentOp= operation.get("parent") as MathOperation;
                            }
                        } else if (nbOperation == 0) {
                            var preprocess_data= computeColsOperation((lSideOperation as ColReference).target, operationOperator, (rSideOperation as ColReference).target, csvData);
                            operation.put("preprocess_data", preprocess_data);
                            operation.put("isMapped", true);
                        } else {
                            operation.put("isMapped", false);
                        }
                    } else {
                        operation.put("isMapped", false);
                        formulaMap.put(currentOp, operation);
                    }
                } 
                    
            }
        } else if (lSide instanceof StatisticalOperation && rSide instanceof StatisticalOperation) {
                var lStat= computeStatisticOperation((lSide as StatisticalOperation).colreference.target, (lSide as StatisticalOperation).operator.literal, csvData);
                var rStat= computeStatisticOperation((rSide as StatisticalOperation).colreference.target, (rSide as StatisticalOperation).operator.literal, csvData);
                var preprocess_data= new ArrayList<String>
                if ((mainOp.operator.literal).equals("+")) {
                	preprocess_data.add((Float.parseFloat(lStat.get(0)) + Float.parseFloat(rStat.get(0))).toString)
                } else if ((mainOp.operator.literal).equals("-")) {
                	preprocess_data.add((Float.parseFloat(lStat.get(0)) - Float.parseFloat(rStat.get(0))).toString)
                }  else if ((mainOp.operator.literal).equals("*")) {
                	preprocess_data.add((Float.parseFloat(lStat.get(0)) * Float.parseFloat(rStat.get(0))).toString)
                } else {
                	preprocess_data.add((Float.parseFloat(lStat.get(0)) / Float.parseFloat(rStat.get(0))).toString)
                }
                operation.put("preprocess_data", preprocess_data)
        		formulaMap.put(mainOp, operation)
                
        } else if (lSide instanceof ColReference && rSide instanceof ColReference) {
        	var lSideOperation= operation.get("l")
        	var rSideOperation= operation.get("r")
        	var operationOperator= operation.get("o") as String
          	var preprocess_data= computeColsOperation((lSideOperation as ColReference).target, operationOperator, (rSideOperation as ColReference).target, csvData);
        	operation.put("preprocess_data", preprocess_data)
        	formulaMap.put(mainOp, operation)
        } else {
        	if (lSide instanceof StatisticalOperation) {
        		var lSideOperation= operation.get("l")
        		var rSideOperation= operation.get("r")
        		var operationOperator= operation.get("o") as String
        		var preprocess_data= computeColsOperation(lSideOperation, operationOperator, (rSideOperation as ColReference).target, csvData)
        		operation.put("preprocess_data", preprocess_data)
        		formulaMap.put(mainOp, operation)
        	} else  {
        		var lSideOperation= operation.get("l")
        		var rSideOperation= operation.get("r")
        		var operationOperator= operation.get("o") as String
        		var preprocess_data= computeColsOperation((lSideOperation as ColReference).target, operationOperator, rSideOperation, csvData)
        		operation.put("preprocess_data", preprocess_data)
        		formulaMap.put(mainOp, operation)
        	}
        }
        newFieldData= (formulaMap.get(mainOp) as HashMap<String, Object>).get("preprocess_data") as ArrayList<String>;
        return newFieldData;
    }
}
